---
title: "Review of milestone 1 (issue 41)"
author: "Mauro Lepore"
date: "2017-08-29"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 6
vignette: >
  %\VignetteIndexEntry{Count Status}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE, message=FALSE, warning=FALSE}
# hadley's settings
set.seed(1014)
options(digits = 3)

knitr::opts_chunk$set(
  echo = TRUE,  # {mine}
  comment = "#>",
  collapse = TRUE,
  # cache = TRUE,
  out.width = "70%",
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)

options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Measuring performance

```{r}
library(forestr)
library(dplyr)

x <- bci12s7mini

system.time({
  with_dplyr <- count_status(x = x, .status = "A", sp)
  with_dplyr <- arrange(with_dplyr, sp)
})

system.time({
  # There may be a faster and more elegant way to do this in base
  .split <- split(x, x$sp)
  applied_1 <- lapply(.split, ctfs::abundance)
  applied_2 <- lapply(applied_1, "[[", "abund")
  
  sp <- names(applied_2)
  n <- lapply(applied_2, "[[", "all")
  n <- unlist(n)
  with_base <- data.frame(sp, n, stringsAsFactors = FALSE)
  with_base <- with_base[order(with_base$sp), ]
})

head(with_dplyr)

head(with_base)

all.equal(with_dplyr, with_base)
```


# Meeting Gabriel

Gabriel proposes to write one single function like thisÑ

```
abundance(x, group_by = c("sp", "status"), only_alive = TRUE)
```

The output should look similar to this:

```{r}
count_status(x, .status = unique(x$status), sp, status) %>% 
  filter(status == "A")

# Same as
group_by(x, status, sp) %>% 
  summarize(n = n()) %>% 
  filter(status == "A")
```

Gabriel proposes getting basal area and biomass simply by changing the function passed to `summarize()`. He prefers less and longer functions over multiple smaller ones.

Contrary to the idea, notice that there is prenty of advice. The following quotes come from "Code Complete (Developer Best Practices)" by Steve McConnell:

> "One way to improve a system is to increase its modularity—increase the number of well-defined, well-named routines that do one thing and do it well."

--http://a.co/dwa6nBZ

> "If a routine executes different code depending on the value of an input parameter, consider breaking the routine into separate routines that can be called separately, without passing in that particular input parameter."

--http://a.co/8rXZUPj

> "A parameter list has too many parameters. Well-factored programs tend to have many small, well-defined routines that don't need large parameter lists. A long parameter list is a warning that the abstraction of the routine interface has not been well thought out. Changes within"

--http://a.co/0GmsFwG






